#summary Tutorial containing API reference and example usages
#labels Featured,Documentation,SortOrder-1

= 1.0 - Introduction =

pyftpdlib implements the server side of the FTP protocol as defined in [http://www.faqs.org/rfcs/rfc959.html RFC-959].  pyftpdlib consist of a single file, *ftpserver.py*, which contains a hierarchy of classes, functions and variables which implement the backend functionality for the ftpd.  This document is intended to serve as a simple *API reference* of most important classes and functions.  Also included is an introduction to *customization* through the use of some example scripts.

If you have written a customized configuration you think could be useful to the community feel free to share it by adding a comment at the end of this document.

= 2.0 - API reference =

=== 2.1 - class AuthorizerError ===

ftpserver.*AuthorizerError()*
    Base class for authorizers exceptions.

= =

=== 2.2 - class DummyAuthorizer ===

ftpserver.*DummyAuthorizer()*

    Basic "dummy" authorizer class, suitable for subclassing to create your own custom authorizers.  An "authorizer" is a class handling authentications and permissions of the FTP server.  It is used inside `FTPHandler` class for verifying user's password, getting users home directory and checking user permissions when a filesystem read/write event occurs.  `DummyAuthorizer` is the base authorizer, providing a platform independent interface for managing "virtual" FTP users.  

    The `perm` argument of the `add_user()` method refers to user's permissions. Every letter is used to indicate that the access rights the current FTP user has over the following specific actions are granted:

    Read permissions:
     * *"e"* = change directory (CWD command)
     * *"l"* = list files (LIST, NLST, MLSD commands)
     * *"r"* = retrieve file from the server (RETR command)

    Write permissions:
     * *"a"* = append data to an existing file (APPE command)
     * *"d"* = delete file or directory (DELE, RMD commands)
     * *"f"* = rename file or directory (RNFR, RNTO commands)
     * *"m"* = create directory (MKD command)
     * *"w"* = store a file to the server (STOR, STOU commands)

    Typically the first thing you have to do is create an instance of this class and start adding ftp users:

{{{
>>> from pyftpdlib import ftpserver
>>> authorizer = ftpserver.DummyAuthorizer()
>>> authorizer.add_user('user', 'password', '/home/user', perm='elradfmw'))
>>> authorizer.add_anonymous('/home/nobody')
}}}

Relevant methods defined in this class:

|| DummyAuthorizer.*add_user(*_username_, _password_, _homedir_*[*, _perm="elr"_*[*, _msg_login="Login successful."_*[*, _msg_quit="Goodbye."_*]**]**])* || Add a user to the virtual users table.  `AuthorizerError` exceptions raised on error conditions such as insufficient permissions or duplicate usernames.  Optional `perm` argument is a set of letters referencing the user's permissions (see the permission table shown above).  Optional `msg_login` and `msg_quit` arguments can be specified to provide customized response strings when user log-in and quit. ||
|| DummyAuthorizer.*add_anonymous(*_homedir_*[*, `**`_kwargs_*])* || Add an anonymous user to the virtual users table.  `AuthorizerError` exception raised on error conditions such as insufficient permissions, missing home directory, or duplicate anonymous users.  The keyword arguments in `kwargs` are the same expected by `add_user()` method: `perm`, `msg_login` and `msg_quit`.  The optional _perm_ keyword argument is a string defaulting to `"elr"` referencing "read-only" anonymous user's permission.  Using a "write" value results in a `RuntimeWarning`. ||
|| DummyAuthorizer.*remove_user(*_username_*)* || Remove a user from the virtual user table. ||
|| DummyAuthorizer.*validate_authentication(*_username_, _password_*)* || Return `True` if the supplied `username` and `password` match the stored credentials. ||
|| DummyAuthorizer.*has_user(*_username_*)* || Whether the `username` exists in the virtual users table. ||
|| DummyAuthorizer.*has_perm(*_username_, _perm_, *[*_path=None_*])* || Whether the user has permission over path (an absolute pathname of a file or a directory). Expected `perm` argument is one of the following letters: `"elradfmw"`. ||
|| DummyAuthorizer.*get_perms(*_username_*)* || Return the user's permissions. ||
|| DummyAuthorizer.*get_home_dir(*_username_*)* || Return the user's home directory. ||


= =

=== 2.3 - class FTPHandler ===

ftpserver.*FTPHandler(*_conn, ftpd_instance_*)*

    This class implements the FTP server Protocol Interpreter (see [http://www.faqs.org/rfcs/rfc959.html RFC-959]), handling commands received from the client on the control channel by calling the command's corresponding method (e.g. for received command "MKD pathname", `ftp_MKD()` method is called with `pathname` as the argument).  All relevant session information are stored in instance variables. 

    `conn` is the underlying socket object instance of the newly established connection, `ftpd_instance` is the `FTPHandler` class instance.  Basic usage simply requires creating an instance of `FTPHandler` class and specify which authorizer instance it will going to use:

{{{
>>> ftp_handler = ftpserver.FTPHandler
>>> ftp_handler.authorizer = authorizer
}}}

All relevant session information is stored in class attributes reproduced below and can be modified before instantiating this class:

|| FTPHandler.*banner* || String sent when client connects (default `"pyftpdlib %s ready." %__ver__`). ||
|| FTPHandler.*max_login_attempts* || Maximum number of wrong authentications before disconnecting (default `3`). ||
|| FTPHandler.*permit_foreign_addresses* || Wether enable [http://www.proftpd.org/docs/howto/FXP.html FXP] feature (default `False`). ||
|| FTPHandler.*permit_privileged_ports* || Set to `True` if you want to permit active connections (PORT) over privileged ports (not recommended, default `False`). ||
|| FTPHandler.*masquerade_address* || The "masqueraded" IP address to provide along PASV reply when pyftpdlib is running behind a NAT or other types of gateways.  When configured pyftpdlib will hide its local address and instead use the public address of your NAT (default `None`). ||
|| FTPHandler.*passive_ports* || What ports ftpd will use for its passive data transfers.  Value expected is a list of integers (e.g. `range(60000, 65535)`).  When configured pyftpdlib will no longer use kernel-assigned random ports (default `None`). ||

All relevant instance attributes and methods initialized when client connects are reproduced below. You may be interested in them in case you want to subclass the original `FTPHandler`.

|| FTPHandler.*authenticated* || `True` if client authenticated himself. ||
|| FTPHandler.*username* || The name of the connected user (if any). ||
|| FTPHandler.*attempted_logins* || The number of currently attempted logins. ||
|| FTPHandler.*current_type* || The current transfer type (default `"a"` (ASCII)). ||
|| FTPHandler.*data_server* || The data server instance (if any). This is the passive data channel waiting for connection. ||
|| FTPHandler.*data_channel* || The data channel instance (if any). This is the connected data channel. ||
|| FTPHandler.*respond(*_resp_*)* || Send a response to client over the command channel. ||
|| FTPHandler.*flush_account()* || Flush account information. ||
|| FTPHandler.*close()* || Close the current channel disconnecting the client. ||

= =

=== 2.4 - class DTPHandler ===

ftpserver.*DTPHandler(*_sock_obj, cmd_channel_*)*

    This class handles the server-data-transfer-process (server-DTP, see [http://www.faqs.org/rfcs/rfc959.html RFC-959]) managing all transfer operations regarding the data channel.  

    `sock_obj` is the underlying socket object instance of the newly established connection, `cmd_channel` is the `FTPHandler` class instance.  Unless you want to add extra functionalities like bandwidth throttling you shouldn't be interested in putting hands on this class.

Relevant instance attributes and methods defined in this class:

|| DTPHandler.*cmd_channel* || The command channel class instance. ||
|| DTPHandler.*file_obj* || The file transferred (if any). ||
|| DTPHandler.*receive* || `True` if channel is used for receiving data. ||
|| DTPHandler.*transfer_finished* || `True` if transfer completed successfully. ||
|| DTPHandler.*get_transmitted_bytes()* || Return the number of transmitted bytes. ||
|| DTPHandler.*transfer_in_progress()* || Return `True` if a transfer is in progress. ||
|| DTPHandler.*enable_receiving(*_type_*)* || Enable receiving of data over the channel.  Depending on the `type` currently in use it creates an appropriate wrapper for the incoming data. ||
|| DTPHandler.*push(*_data_*)* || Push a bufferable _data_ object (e.g. a string) onto the deque and initiate send. ||
|| DTPHandler.*push_with_producer(*_producer_*)* || Push data using a `producer` and initiate send. ||
|| DTPHandler.*close()* || Close the data channel, first attempting to close any remaining file handles. ||

= =

=== 2.5 - class FTPServer ===

ftpserver.*FTPServer(*_address, handler_*)*

    This class is an `asyncore.dispatcher` subclass.  It creates a FTP socket listening on `address` (a tuple containing the ip:port pair), dispatching the requests to a "handler" (typically `FTPHandler` class object).  It is typically used for starting asyncore polling loop:

{{{
>>> address = ('127.0.0.1', 21)
>>> ftpd = ftpserver.FTPServer(address, ftp_handler)
>>> ftpd.serve_forever()
}}}

Relevant methods and attributes defined in this class:

|| FTPServer.*max_cons* || Number of maximum simultaneous connections accepted (default `0` == _no limit_). ||
|| FTPServer.*max_cons_per_ip* || Number of maximum connections accepted for the same IP address (default `0` == _no limit_). ||
|| FTPServer.*serve_forever([*, `**`_kwargs_*])* || Starts the asyncore polling loop. The keyword arguments in `kwargs` are the same expected by asyncore.loop() function: `timeout`, `use_poll`, `map` and `count`. ||
|| FTPServer.*close()* || Stop serving without disconnecting currently connected clients. ||
|| FTPServer.*close_all([*_map=None_*[*, _ignore_all=False_*]])* || Stop serving disconnecting also the currently connected clients. The `map` parameter is a dictionary whose items are the channels to close. If `map` is omitted, the default `asyncore.socket_map` is used. Having `ignore_all` parameter set to `False` results in raising exception in case of unexpected errors. ||

= =

=== 2.6 - class AbstractedFS ===

ftpserver.*AbstractedFS()*
    A class used to interact with the file system, providing a high level, cross-platform interface compatible with both Windows and UNIX style filesystems.  It provides some utility methods and some wraps around operations involved in file object creation and file system operations like moving files or removing directories.

Relevant attributes and methods defined in this class:

|| AbstractedFS.*root* || User's home directory ("real"). ||
|| AbstractedFS.*cwd* || User's current working directory ("virtual"). ||
|| AbstractedFS.*ftpnorm(*_ftppath_*)* || Normalize a "virtual" ftp pathname depending on the current working directory (e.g. having "/foo" as current working directory "x" becomes "/foo/x"). _*New in 3.0*_ ||
|| AbstractedFS.*ftp2fs(*_ftppath_*)* || Translate a "virtual" ftp pathname into equivalent absolute "real" filesystem pathname (e.g. having "/home/user" as root directory "x" becomes  "/home/user/x"). _*New in 3.0*_ ||
|| AbstractedFS.*fs2ftp(*_fspath_*)* || Translate a "real" filesystem pathname into equivalent absolute "virtual" ftp pathname depending on the user's root directory (e.g. having "/home/user" as root directory "/home/user/x" becomes "/x". _*New in 3.0*_||
|| AbstractedFS.*validpath(*_path_*)* || Check whether the path belongs to user's home directory. Expected argument is a "real" filesystem path. If path is a symbolic link it is resolved to check its real destination. Pathnames escaping from user's root directory are considered not valid (return `False`). ||
|| AbstractedFS.*format_list(*_basedir_, _listing_*[*, _ignore_err=False_*])* || Return an iterator object that yields the entries of given directory emulating the "/bin/ls -lA" UNIX command output. `basedir` is the absolute dirname, `listing` a list containing the names of the entries in `basedir`. If an error occurs (`os.lstat()` call fails) no exception is raised unless `ignore_err` is set to `True`. ||
|| AbstractedFS.*format_mlsx(*_basedir_, _listing_, _perms_, _facts_*[*, _ignore_err=False_*])* || Return an iterator object that yields the entries of a given directory or of a single file in a form suitable with MLSD and MLST commands. `basedir` is the absolute dirname, `listing` a list containing the names of the entries in `basedir`, `perms` a string referencing user permissions, `facts` a list of "facts" to be returned. If an error occurs (`os.stat()` call fails) no exception is raised unless `ignore_err` is set to `True`. _*New in 3.0*_||

= =

=== 2.7 - Functions ===

ftpserver.*log(*_msg_*)*
    Log messages intended for the end user.

ftpserver.*logline(*_msg_*)*
    Log commands and responses passing through the command channel.

ftpserver.*logerror(*_msg_*)*
    Log traceback outputs occurring in case of errors.


= 3.0 - Customizing your FTP server =

Below is a set of example scripts showing some of the possible customizations that can be done with pyftpdlib.  Some of them are included in demo directory of pyftpdlib source distribution.

=== 3.1 - Building a Base FTP server ===

The script below is a basic configuration, and it's probably the best starting point for understanding how things work. It uses the base `DummyAuthorizer` for adding a bunch of "virtual" users.

It also sets a limit for connections by overriding `FTPServer.max_cons` and `FTPServer.max_cons_per_ip` attributes which are intended to set limits for maximum connections to handle simultaneously and maximum connections from the same IP address.
Overriding these variables is always a good idea (they default to `0`, or "no limit") since they are a good workaround for avoiding DoS attacks.

{{{
#!/usr/bin/env python
# basic_ftpd.py
    
"""A basic FTP server which uses a DummyAuthorizer for managing 'virtual
users', setting a limit for incoming connections.
"""
    
import os
    
from pyftpdlib import ftpserver
    
    
if __name__ == "__main__":
    
    # Instantiate a dummy authorizer for managing 'virtual' users
    authorizer = ftpserver.DummyAuthorizer()
    
    # Define a new user having full r/w permissions and a read-only
    # anonymous user
    authorizer.add_user('user', '12345', os.getcwd(), perm='elradfmw')
    authorizer.add_anonymous(os.getcwd())
    
    # Instantiate FTP handler class
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    
    # Define a customized banner (string returned when client connects)
    ftp_handler.banner = "pyftpdlib %s based ftpd ready." %ftpserver.__ver__
        
    # Specify a masquerade address and the range of ports to use for
    # passive connections.  Decomment in case you're behind a NAT.
    #ftp_handler.masquerade_address = '151.25.42.11'
    #ftp_handler.passive_ports = range(60000, 65535)
    
    # Instantiate FTP server class and listen to 0.0.0.0:21
    address = ('', 21)
    ftpd = ftpserver.FTPServer(address, ftp_handler)
    
    # set a limit for connections
    ftpd.max_cons = 256
    ftpd.max_cons_per_ip = 5
    
    # start ftp server
    ftpd.serve_forever()
}}}


=== 3.2 - Logging management ===

As mentioned, ftpserver.py comes with 3 different functions intended for a separate logging system: `log()`, `logline()` and `logerror()`.
Let's suppose you don't want to print FTPd messages on screen but you want to write them into different files: _"/var/log/ftpd.log"_ will be main log file, _"/var/log/ftpd.lines.log"_ the one where you'll want to store commands and responses passing through the control connection.

Here's one method this could be implemented:

{{{
#!/usr/bin/env python
# logging_management.py
    
import os
import time
    
from pyftpdlib import ftpserver
    
now = lambda: time.strftime("[%Y-%b-%d %H:%M:%S]")
    
def standard_logger(msg):
    f1.write("%s %s\n" %(now(), msg))
    
def line_logger(msg):
    f2.write("%s %s\n" %(now(), msg))
    
if __name__ == "__main__":
    f1 = open('ftpd.log', 'a')
    f2 = open('ftpd.lines.log', 'a')
    ftpserver.log = standard_logger
    ftpserver.logline = line_logger
    
    authorizer = ftpserver.DummyAuthorizer()
    authorizer.add_anonymous(os.getcwd())
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    address = ('', 21)
    ftpd = ftpserver.FTPServer(address, ftp_handler)
    ftpd.serve_forever()
}}}


=== 3.3 - Storing passwords as hash digests ===

Using FTP server library with the default `DummyAuthorizer` means that password will be stored in clear-text. An end-user ftpd using the default dummy authorizer would typically require a configuration file for authenticating users and their passwords but storing clear-text passwords is of course undesirable.

The most common way to do things in such case would be first creating new users and then storing their usernames + passwords as hash digests into a file or wherever you find it convenient.

The example below shows how to easily create an encrypted account storage system by storing passwords as one-way hashes by using md5 algorithm.
This could be easily done by using the *md5* module included with Python stdlib and by sub-classing the original `DummyAuthorizer` class overriding its `validate_authentication()` method:

{{{
#!/usr/bin/env python
# md5_ftpd.py
    
"""A basic ftpd storing passwords as hash digests (platform independent).
"""
    
import md5
import os
    
from pyftpdlib import ftpserver
    
    
class DummyMD5Authorizer(ftpserver.DummyAuthorizer):
    
    def validate_authentication(self, username, password):
        hash = md5.new(password).hexdigest()
        return self.user_table[username]['pwd'] == hash
    
if __name__ == "__main__":
    # get a hash digest from a clear-text password
    hash = md5.new('12345').hexdigest()
    authorizer = DummyMD5Authorizer()
    authorizer.add_user('user', hash, os.getcwd(), perm='elradfmw')
    authorizer.add_anonymous(os.getcwd())
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    address = ('', 21)
    ftpd = ftpserver.FTPServer(address, ftp_handler)
    ftpd.serve_forever()
}}}


=== 3.4 - Unix FTP Server ===

If you're running a Unix system you may want to configure your ftpd to include support for "real" users existing on the system.

The example below shows how to use *pwd* and *spwd* modules available in _Python 2.5_ or greater (UNIX systems only) to interact with UNIX user account and shadow password database. This basic authorizer also gets the user's home directory.

Note that users must already exist on the system.

{{{
#!/usr/bin/env python
# unix_ftpd.py
    
"""A ftpd using local unix account database to authenticate users
(users must already exist).
"""
    
import os
import pwd, spwd, crypt
    
from pyftpdlib import ftpserver
    
    
class UnixAuthorizer(ftpserver.DummyAuthorizer):
    
    def add_user(self, username, home=None, **kwargs):
        """Add a "real" system user to the virtual users table.
    
        If no home argument is specified the user's home directory will
        be used.
        The keyword arguments in kwargs are the same expected by the
        original add_user method: "perm", "msg_login" and "msg_quit".
        """
        # get the list of all available users on the system and check
        # if provided username exists
        users = [entry.pw_name for entry in pwd.getpwall()]
        if not username in users:
            raise ftpserver.AuthorizerError('No such user "%s".' %username)
        if not home:
            home = pwd.getpwnam(username).pw_dir
        ftpserver.DummyAuthorizer.add_user(self, username, '', home, **kwargs)
    
    def validate_authentication(self, username, password):
        pw1 = spwd.getspnam(username).sp_pwd
        pw2 = crypt.crypt(password, pw1)
        return pw1 == pw2
    
if __name__ == "__main__":
    authorizer = UnixAuthorizer()
    # add a user (note: user must already exists)
    authorizer.add_user('user', perm='elradfmw')
    authorizer.add_anonymous(os.getcwd())
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    address = ('', 21)
    ftpd = ftpserver.FTPServer(address, ftp_handler)
    ftpd.serve_forever()
}}}


=== 3.5 - Windows NT FTP Server ===

This next code shows how to implement a basic authorizer for a *Windows NT* workstation (windows NT, 2000, XP, 2003 server and so on...) to authenticate against existing Windows user accounts. This code uses Mark Hammond's [http://starship.python.net/crew/mhammond/win32/ pywin32] extension so the PyWin32 extensions must also be installed.

Note that, as for UNIX authorizer, users must be already created on the system.

{{{
#!/usr/bin/env python
# winnt_ftpd.py

"""A ftpd using local Windows NT account database to authenticate users
(users must already exist).
"""

import os
import win32security, win32net, win32profile, pywintypes
    
from pyftpdlib import ftpserver
    
    
class WinNtAuthorizer(ftpserver.DummyAuthorizer):
    
    def add_user(self, username, home=None, **kwargs):
        """Add a "real" system user to the virtual users table.
    
        If no home argument is specified the user's home directory will
        be used.
        The keyword arguments in kwargs are the same expected by the
        original add_user method: "perm", "msg_login" and "msg_quit".
        """
        # get the list of all available users on the system and check
        # if provided username exists
        users = [entry['name'] for entry in win32net.NetUserEnum(None, 0)[0]]
        if not username in users:
            raise ftpserver.AuthorizerError('No such user "%s".' %username)
        if not home:
            profiles = win32profile.GetProfilesDirectory()
            home = str(os.path.join(profiles, username))
        ftpserver.DummyAuthorizer.add_user(self, username, '', home, **kwargs)
    
    def validate_authentication(self, username, password):
        try:
            win32security.LogonUser(username, None, password,
                win32security.LOGON32_LOGON_NETWORK,
                win32security.LOGON32_PROVIDER_DEFAULT)
            return 1
        except pywintypes.error:
            return 0
    
if __name__ == "__main__":
    authorizer = WinNtAuthorizer()
    # add a user (note: user must already exists)
    authorizer.add_user('user', perm='elradfmw')
    authorizer.add_anonymous(os.getcwd())
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    address = ('', 21)
    ftpd = ftpserver.FTPServer(address, ftp_handler)
    ftpd.serve_forever()
}}}