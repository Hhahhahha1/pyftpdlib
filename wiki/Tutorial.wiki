#summary Tutorial containing API reference and example usages
#labels SortOrder-1,Featured

= Table of contents =

<wiki:toc/>

= 1.0 - Introduction =

pyftpdlib implements the server side of the FTP protocol as defined in [http://www.faqs.org/rfcs/rfc959.html RFC-959].  pyftpdlib consist of a single file, [http://code.google.com/p/pyftpdlib/source/browse/trunk/pyftpdlib/ftpserver.py ftpserver.py], which contains a hierarchy of classes which implement the backend functionality for the ftpd. <br> This document is intended to serve as a simple [http://code.google.com/p/billiejoex/wiki/Tutorial#2.0_-_API_reference API reference] of most important classes and functions.  Also included is an introduction to [http://code.google.com/p/billiejoex/wiki/Tutorial#3.0_-_Customizing_your_FTP_server customization] through the use of some example scripts.
Some of them are included in [http://code.google.com/p/pyftpdlib/source/browse/#svn/trunk/demo demo] directory of pyftpdlib source distribution.

If you have written a customized configuration you think could be useful to the community feel free to share it by adding a comment at the end of this document.

= 2.0 - API reference =

== 2.1 - Logging ==

_function_ pyftpdlib.ftpserver.*log*<font size="3">*`(`*</font>_msg_<font size="3">*`)`*</font>
  Log messages intended for the end user.
----
_function_ pyftpdlib.ftpserver.*logline*<font size="3">*`(`*</font>_msg_<font size="3">*`)`*</font>
  Log commands and responses passing through the command channel.
----
_function_ pyftpdlib.ftpserver.*logerror*<font size="3">*`(`*</font>_msg_<font size="3">*`)`*</font>
  Log traceback outputs occurring in case of errors.
----

== 2.2 - Users ==

_class_ pyftpdlib.ftpserver.*DummyAuthorizer*<font size="3">*`()`*</font>

  Basic "dummy" authorizer class, suitable for subclassing to create your own custom authorizers. An "authorizer" is a class handling authentications and permissions of the FTP server.  It is used inside `FTPHandler` class for verifying user's password, getting users home directory, checking user permissions when a filesystem read/write event occurs and changing user before accessing the filesystem. `DummyAuthorizer` is the base authorizer, providing a platform independent interface for managing "virtual" FTP users.  Typically the first thing you have to do is create an instance of this class and start adding ftp users:

  {{{
>>> from pyftpdlib import ftpserver
>>> authorizer = ftpserver.DummyAuthorizer()
>>> authorizer.add_user('user', 'password', '/home/user', perm='elradfmw')
>>> authorizer.add_anonymous('/home/nobody')
  }}}

 * *add_user*<font size="3">*`(`*</font>_username_, _password_, _homedir_<font size="3">*`[`*</font>, _perm="elr"_<font size="3">*`[`*</font>, _msg_login="Login successful."_<font size="3">*`[`*</font>, _msg_quit="Goodbye."_ <font size="3">*`]]])`*</font>      <br>Add a user to the virtual users table.  `AuthorizerError` exceptions raised on error conditions such as insufficient permissions or duplicate usernames.  Optional `perm` argument is a set of letters referencing the user's permissions.  Every letter is used to indicate that the access rights the current FTP user has over the following specific actions are granted.  The available permissions are the following listed below:

  Read permissions:
      * *"e"* = change directory (CWD, CDUP commands)
      * *"l"* = list files (LIST, NLST, STAT, MLSD, MLST, SIZE commands)
      * *"r"* = retrieve file from the server (RETR command)
  Write permissions
      * *"a"* = append data to an existing file (APPE command)
      * *"d"* = delete file or directory (DELE, RMD commands)
      * *"f"* = rename file or directory (RNFR, RNTO commands)
      * *"m"* = create directory (MKD command)
      * *"w"* = store a file to the server (STOR, STOU commands)
      * *"M"* = change mode/permission (SITE CHMOD command)  _*New in 0.7.0*_

 Optional `msg_login` and `msg_quit` arguments can be specified to provide customized response strings when user log-in and quit.  The `perm` argument of the `add_user()` method refers to user's permissions. Every letter is used to indicate that the access rights the current FTP user has over the following specific actions are granted.

 * *add_anonymous*<font size="3">*`(`*</font>_homedir_<font size="3">*`[`*</font>, `**`_kwargs_<font size="3">*`])`*</font><br>Add an anonymous user to the virtual users table.  `AuthorizerError` exception raised on error conditions such as insufficient permissions, missing home directory, or duplicate anonymous users.  The keyword arguments in `kwargs` are the same expected by `add_user()` method: `perm`, `msg_login` and `msg_quit`.  The optional _perm_ keyword argument is a string defaulting to `"elr"` referencing "read-only" anonymous user's permission.  Using a "write" value results in a `RuntimeWarning`.

 * *override_perm*<font size="3">*`(`*</font>_username_, _directory_, _perm_<font size="3">*`[`*</font>, _recursive=False_<font size="3">*`])`*</font><br>Override user permissions for a given directory. 

 * *validate_authentication*<font size="3">*`(`*</font>_username_, _password_<font size="3">*`)`*</font><br>Return `True` if the supplied `username` and `password` match the stored credentials.

 * *impersonate_user*<font size="3">*`(`*</font>_username_, _password_<font size="3">*`)`*</font><br>Impersonate another user (noop).  It is always called before accessing the filesystem.  By default it does nothing.  The subclass overriding this method is expected to provide a mechanism to change the current user.

 * *terminate_impersonation*<font size="3">*`(`*</font>_username_<font size="3">*`)`*</font><br>Terminate impersonation (noop).  It is always called after having accessed the filesystem.  By default it does nothing.  The subclass overriding this method is expected to provide a mechanism to switch back to the original user.

 * *remove_user*<font size="3">*`(`*</font>_username_<font size="3">*`)`*</font><br>Remove a user from the virtual user table.
----

== 2.3 - Control connection ==

class pyftpdlib.ftpserver.*FTPHandler*<font size="3">*`(`*</font>_conn, server_<font size="3">*`)`*</font>

  This class implements the FTP server Protocol Interpreter (see [http://www.faqs.org/rfcs/rfc959.html RFC-959]), handling commands received from the client on the control channel by calling the command's corresponding method (e.g. for received command "MKD pathname", `ftp_MKD()` method is called with `pathname` as the argument).  All relevant session information are stored in instance variables.  `conn` is the underlying socket object instance of the newly established connection, `server` is the `FTPServer` class instance.  Basic usage simply requires creating an instance of `FTPHandler` class and specify which authorizer instance it will going to use:

{{{
>>> ftp_handler = ftpserver.FTPHandler
>>> ftp_handler.authorizer = authorizer
}}}

  All relevant session information is stored in class attributes reproduced below and can be modified before instantiating this class:

 * *timeout*<br>The timeout which is the maximum time a remote client may spend between FTP commands. If the timeout triggers, the remote client will be kicked off (defaults to `300` seconds). _*New in version 5.0*_

 * *banner*<br>String sent when client connects (default `"pyftpdlib %s ready." %__ver__`).

 * *max_login_attempts*<br>Maximum number of wrong authentications before disconnecting (default `3`).

 * *permit_foreign_addresses*<br>Whether enable [http://www.proftpd.org/docs/howto/FXP.html FXP] feature (default `False`).

 * *permit_privileged_ports*<br>Set to `True` if you want to permit active connections (PORT) over privileged ports (not recommended, default `False`).

 * *masquerade_address*<br>The "masqueraded" IP address to provide along PASV reply when pyftpdlib is running behind a NAT or other types of gateways.  When configured pyftpdlib will hide its local address and instead use the public address of your NAT (default `None`).

 * *masquerade_address_map*<br>In case the server has multiple IP addresses which are all behind a NAT router, you may wish to specify individual masquerade_addresses for each of them. The map expects a dictionary containing private IP addresses as keys, and their corresponding public (masquerade) addresses as values (defaults to `{}`). _*New in version 0.6.0*_

 * *passive_ports*<br>What ports ftpd will use for its passive data transfers.  Value expected is a list of integers (e.g. `range(60000, 65535)`).  When configured pyftpdlib will no longer use kernel-assigned random ports (default `None`).

 * *use_gmt_times*<br>When True causes the server to report all ls and MDTM times in GMT and not local time (default `True`). _*New in version 0.6.0*_

 * *tcp_no_delay*<br>Controls the use of the TCP_NODELAY socket option which disables the Nagle algorithm resulting in significantly better performances (default `True` on all platforms where it is supported). _*New in version 0.6.0*_

 * *use_sendfile*<br>when True uses sendfile() system call to send a file resulting in faster uploads (from server to client). Works on UNIX only and requires pysendfile module to be installed separately: http://code.google.com/p/pysendfile/ _*New in version 0.7.0*_

  <br>Follows a list of callback methods that can be overridden in a subclass. For blocking operations read the FAQ on how to [http://code.google.com/p/pyftpdlib/wiki/FAQ#How_can_I_run_long-running_tasks_without_blocking_the_server? run time consuming tasks]

 * *on_login*<font size="3">*`(`*</font>_username_<font size="3">*`)`*</font><br>Called on user login. _*New in version 0.6.0*_

 * *on_login_failed*<font size="3">*`(`*</font>_username_, _password_<font size="3">*`)`*</font><br>Called on failed user login. _*New in version 0.7.0*_

 * *on_logout*<font size="3">*`(`*</font>_username_<font size="3">*`)`*</font><br>Called when user logs out due to QUIT or USER issued twice. This is not called if client just disconnects without issuing QUIT first. <br /> _*New in version 0.6.0*_

 * *on_file_sent*<font size="3">*`(`*</font>_file_<font size="3">*`)`*</font><br>Called every time a file has been successfully sent. `file` is the absolute name of that file. 

 * *on_file_received*<font size="3">*`(`*</font>_file_<font size="3">*`)`*</font><br>Called every time a file has been successfully received. `file` is the absolute name of that file. 

 * *on_incomplete_file_sent*<font size="3">*`(`*</font>_file_<font size="3">*`)`*</font><br>Called every time a file has not been entirely sent (e.g. transfer aborted by client). `file` is the absolute name of that file. _*New in version 0.6.0*_

 * *on_incomplete_file_received*<font size="3">*`(`*</font>_file_<font size="3">*`)`*</font><br>Called every time a file has not been entirely received (e.g. transfer aborted by client). `file` is the absolute name of that file. _*New in version 0.6.0*_

----
== 2.4 - Data connection ==

_class_ pyftpdlib.ftpserver.*DTPHandler*<font size="3">*`(`*</font>_sock_obj, cmd_channel_<font size="3">*`)`*</font>

  This class handles the server-data-transfer-process (server-DTP, see [http://www.faqs.org/rfcs/rfc959.html RFC-959]) managing all transfer operations regarding the data channel.  `sock_obj` is the underlying socket object instance of the newly established connection, `cmd_channel` is the `FTPHandler` class instance.

 * *timeout*<br>The timeout which roughly is the maximum time we permit data transfers to stall for with no progress. If the timeout triggers, the remote client will be kicked off. 

 * *ac_in_buffer_size*<br>
 * *ac_out_buffer_size*<br>The buffer sizes to use when receiving and sending data (both defaulting to `65536` bytes). For LANs you may want this to be fairly large.  Depending on available memory and number of connected clients setting them to a lower value can result in better performances.

----
_class_ pyftpdlib.ftpserver.*ThrottledDTPHandler*<font size="3">*`(`*</font>_sock_obj, cmd_channel_<font size="3">*`)`*</font>

  A `DTPHandler` subclass which wraps sending and receiving in a data counter and temporarily "sleeps" the channel so that you burst to no more than x Kb/sec average. Use it instead of `DTPHandler` to set transfer rates limits for both downloads and/or uploads (see the [http://code.google.com/p/pyftpdlib/source/browse/trunk/demo/throttled_ftpd.py demo script] showing the example usage). 

 * *read_limit*<br>The maximum number of bytes to read (receive) in one second (defaults to 0 == no limit)

 * *write_limit*<br>The maximum number of bytes to write (send) in one second (defaults to 0 == no limit).
----
== 2.4 - Server (acceptor) ==

_class_ pyftpdlib.ftpserver.*FTPServer*<font size="3">*`(`*</font>_address, handler_<font size="3">*`)`*</font>

  This class is an `asyncore.dispatcher` subclass.  It creates a FTP socket listening on `address` (a tuple containing the ip:port pair), dispatching the requests to a "handler" (typically `FTPHandler` class object).  It is typically used for starting asyncore polling loop:

  {{{
>>> address = ('127.0.0.1', 21)
>>> ftpd = ftpserver.FTPServer(address, ftp_handler)
>>> ftpd.serve_forever()
  }}}

 * *max_cons*<br>Number of maximum simultaneous connections accepted (default `512`).

 * *max_cons_per_ip*<br>Number of maximum connections accepted for the same IP address (default `0` == _no limit_).

 * *serve_forever(*<font size="3">*`[`*</font>_timeout=1_<font size="3">*`[`*</font>, _use_poll=False_<font size="3">*`[`*</font>, _count=None_<font size="3">*`]])`*</font><br>A wrap around asyncore.loop(); starts the asyncore polling loop including running the scheduler. The arguments are the same expected by original [http://docs.python.org/library/asyncore.html#asyncore.loop asyncore.loop()] function.  _*Changed in version 0.7.0*: turned into a classmethod_

 * *close*<font size="3">*`()`*</font><br>Stop serving without disconnecting currently connected clients.

 * *close_all(*<font size="3">*`[`*</font>, _ignore_all=False_<font size="3">*`]])`*</font><br>Stop serving disconnecting also the currently connected clients. The `map` parameter is a dictionary whose items are the channels to close. If `map` is omitted, the default `asyncore.socket_map` is used. Having `ignore_all` parameter set to `False` results in raising exception in case of unexpected errors.
----
== 2.6 - File system ==

_class_ pyftpdlib.ftpserver.*AbstractedFS(*_root_, _cmd_channel_*)*

  A class used to interact with the file system, providing a cross-platform interface compatible with both Windows and UNIX style filesystems where all paths use "/" separator. <br>`AbstractedFS` distinguishes between "real" filesystem paths and "virtual" ftp paths emulating a UNIX chroot jail where the user can not escape its home directory (example: real "/home/user" path will be seen as "/" by the client). <br>It also provides some utility methods and wraps around all `os.*` calls involving operations against the filesystem like creating files or removing directories. The contructor accepts two arguments: `root` which is the user "real" home directory (e.g. '/home/user') and `cmd_channel` which is the `FTPHandler` class instance.

 _*Changed in version 0.6.0*: `root` and `cmd_channel` arguments were added._

 * *root*<br>User's home directory ("real").  _*Changed in version 0.7.0*: support setattr()_

 * *cwd*<br>User's current working directory ("virtual").  _*Changed in version 0.7.0*: support setattr()_

 * *ftpnorm*<font size="3">*`(`*</font>_ftppath_<font size="3">*`)`*</font><br>Normalize a "virtual" ftp pathname depending on the current working directory (e.g. having "/foo" as current working directory "x" becomes "/foo/x").

 * *ftp2fs*<font size="3">*`(`*</font>_ftppath_<font size="3">*`)`*</font><br>Translate a "virtual" ftp pathname into equivalent absolute "real" filesystem pathname (e.g. having "/home/user" as root directory "x" becomes  "/home/user/x").

 * *fs2ftp*<font size="3">*`(`*</font>_fspath_<font size="3">*`)`*</font><br>Translate a "real" filesystem pathname into equivalent absolute "virtual" ftp pathname depending on the user's root directory (e.g. having "/home/user" as root directory "/home/user/x" becomes "/x".

 * *validpath*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>Check whether the path belongs to user's home directory. Expected argument is a "real" filesystem path. If path is a symbolic link it is resolved to check its real destination. Pathnames escaping from user's root directory are considered not valid (return `False`).

 * *open*<font size="3">*`(`*</font>_filename, mode_<font size="3">*`)`*</font><br>Wrapper around [http://docs.python.org/library/functions.html#open open()] builtin.

 * *mkdir*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*chdir*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*listdir*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*rmdir*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*remove*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*rename*<font size="3">*`(`*</font>_src, dst_<font size="3">*`)`*</font><br>*chmod*<font size="3">*`(`*</font>_path, mode_<font size="3">*`)`*</font><br>*stat*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*lstat*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>Wrappers around corresponding [http://docs.python.org/library/os.html os] module functions.

 * *isfile*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*islink*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*isdir*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*getsize*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*getmtime*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*realpath*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>*lexists*<font size="3">*`(`*</font>_path_<font size="3">*`)`*</font><br>Wrappers around corresponding [http://docs.python.org/library/os.path.html os.path] module functions.

 * *mkstemp*<font size="3">*`(`*</font>suffix='', prefix='', dir=None, mode='wb'<font size="3">*`)`*</font><br>Wrapper around [http://docs.python.org/library/tempfile.html#tempfile.mkstemp tempfile.mkstemp].

----

= 2.1 - Contrib package =

Starting from version 0.6.0 a new `contrib` package has been added to `pyftpdlib` namespace which extends base `ftpserver.py` module. Modules contained in here usually requires third-party modules to be installed separately or are specific for a given Python version or operating system.

----

== 2.2 - pyftpdlib.contrib.handlers module ==

This module provides basic support for FTPS (FTP over SSL/TLS) as described in [http://www.ietf.org/rfc/rfc4217.txt RFC-4217] implementing AUTH, PBSZ and PROT commands.
In order to make it work [http://pypi.python.org/pypi/pyOpenSSL PyOpenSSL module] is required to be installed. [http://code.google.com/p/billiejoex/wiki/Tutorial?ts=1284112249&updated=Tutorial#3.7_-_FTPS_(FTP_over_TLS/SSL)_server Example below] shows how to setup an FTPS server.

_class_ pyftpdlib.contrib.handlers.*TLS_FTPHandler(*_conn_, _server_*)*
  A `ftpserver.FTPHandler` subclass supporting TLS/SSL. Configurable attributes:

  * *certfile*<br>The path to a file which contains a certificate to be used to identify the local side of the connection. This must always be specified, unless context is provided instead.

  * *keyfile*<br>The path of the file containing the private RSA key; can be omittetted if certfile already contains the private key (defaults: `None`).

  * *tls_control_required*<br>When `True` requires SSL/TLS to be established on the control channel, before logging in. This means the user will have to issue AUTH before USER/PASS (default `False`).

  * *tls_data_required*<br>When `True` requires SSL/TLS to be established on the data channel. This means the user will have to issue PROT before PASV or PORT (default `False`).
  
----

== 2.3 - pyftpdlib.contrib.authorizers module ==

This module contains two classes for handling users on Unix and Windows systems. Users are no longer supposed to be explicitly added as when using `DummyAuthorizer`.<br>All FTP users are the same defined on the UNIX or Windows system so if you access on your system by using "john" as username and "12345" as password those same credentials can be used for accessing the FTP server as well.<br>The user home directories will be automatically determined when user logins (e.g. /home/user on Unix, C:\Documents and settings\user on Windows).<br>Every time a filesystem operation occurs (e.g. a file is created or deleted) the id of the process is temporarily changed to the effective user id and whether the operation will succeed depends on user and file permissions. This is why full read and write permissions are granted by default in the class constructors.

_class_ pyftpdlib.contrib.authorizers.*UnixAuthorizer(*_global_perm="elradfmw"_, _allowed_users=`[]`_, _rejected_users=`[]`_, _require_valid_shell=True_, _anonymous_user=None_, ,_msg_login="Login successful."_, _msg_quit="Goodbye."_*)*

   `global_perm` is a series of letters referencing the users permissions; defaults to `"elradfmw"` which means full read and write access for everybody (except anonymous). `allowed_users` and `rejected_users` options expect a list of users which are accepted or rejected for authenticating against the FTP server; defaults both to `[]` (no restrictions). `require_valid_shell` deny access for those users which do not have a valid shell binary listed in /etc/shells. If /etc/shells cannot be found this is a no-op.  Anonymous user is not subject to this option, and is free to not have a valid shell defined. Defaults to `True` (a valid shell is required for login). `anonymous_user` can be specified if you intend to provide anonymous access. The value expected is a string representing the system user to use for managing anonymous sessions; defaults to `None`  (anonymous access disabled).<br> Note that in order to use this class super user privileges are required.
 
 _*New in version 0.6.0*_

 * *override_user(*_username=None_, _password=None_, _homedir=None_, _perm=None_, _anonymous_user=None_, _msg_login=None_, _msg_quit=None_*)*<br>Overrides one or more options specified in the class constructor for a specific user.

 Examples:

{{{
>>> from pyftpdlib.contrib.authorizers import UnixAuthorizer
>>> auth = UnixAuthorizer(rejected_users=["root"])
>>> auth = UnixAuthorizer(allowed_users=["matt", "jay"])
>>> auth = UnixAuthorizer(require_valid_shell=False)
>>> auth.override_user("matt", password="foo", perm="elr")
}}}

----

_class_ pyftpdlib.contrib.authorizers.*WindowsAuthorizer(*_global_perm="elradfmw"_, _allowed_users=`[]`_, _rejected_users=`[]`_, _anonymous_user=None_, _anonymous_password=""_, _msg_login="Login successful."_, _msg_quit="Goodbye."_*)*:

  Same as `UnixAuthorizer` except for _anonymous_password_ argument which must be specified when defining the _anonymous_user_.<br>Also _requires_valid_shell_ option is not available. In order to use this class [http://sourceforge.net/projects/pywin32/ pywin32 extension] must be installed.

 _*New in version 0.6.0*_
 
----

== 2.4 - pyftpdlib.contrib.filesystems module ==

class pyftpdlib.contrib.filesystems.*UnixFilesystem(*_root_, _cmd_channel_*)*
  Represents the real UNIX filesystem. Differently from AbstractedFS the client will login into  `/home/<username>` and will be able to escape its home directory and navigate the real filesystem. Use it in conjuction with `UnixAuthorizer` to implement a "real" UNIX FTP server (see [http://pyftpdlib.googlecode.com/svn/trunk/demo/unix_ftpd.py demo/unix_ftpd.py]).

 _*New in version 0.6.0*_

----

= 3.0 - Customizing your FTP server =

Below is a set of example scripts showing some of the possible customizations that can be done with pyftpdlib.  Some of them are included in [http://code.google.com/p/pyftpdlib/source/browse/#svn/trunk/demo demo] directory of pyftpdlib source distribution.

== 3.1 - Building a Base FTP server ==

The script below is a basic configuration, and it's probably the best starting point for understanding how things work. It uses the base `DummyAuthorizer` for adding a bunch of "virtual" users.

It also sets a limit for connections by overriding `FTPServer.max_cons` and `FTPServer.max_cons_per_ip` attributes which are intended to set limits for maximum connections to handle simultaneously and maximum connections from the same IP address.
Overriding these variables is always a good idea (they default to `0`, or "no limit") since they are a good workaround for avoiding DoS attacks.

[http://pyftpdlib.googlecode.com/svn/trunk/demo/basic_ftpd.py download script]

{{{
from pyftpdlib import ftpserver

def main():
    # Instantiate a dummy authorizer for managing 'virtual' users
    authorizer = ftpserver.DummyAuthorizer()

    # Define a new user having full r/w permissions and a read-only
    # anonymous user
    authorizer.add_user('user', password="12345", homedir='.', perm='elradfmw')
    authorizer.add_anonymous(homedir='.')

    # Instantiate FTP handler class
    handler = ftpserver.FTPHandler
    handler.authorizer = authorizer

    # Define a customized banner (string returned when client connects)
    handler.banner = "pyftpdlib %s based ftpd ready." %ftpserver.__ver__

    # Specify a masquerade address and the range of ports to use for
    # passive connections.  Decomment in case you're behind a NAT.
    #ftp_handler.masquerade_address = '151.25.42.11'
    #ftp_handler.passive_ports = range(60000, 65535)

    # Instantiate FTP server class and listen to 0.0.0.0:21
    address = ('', 21)
    server = ftpserver.FTPServer(address, handler)

    # set a limit for connections
    server.max_cons = 256
    server.max_cons_per_ip = 5

    # start ftp server
    server.serve_forever()

if __name__ == '__main__':
    main()
}}}


== 3.2 - Logging management ==

As mentioned, ftpserver.py comes with 3 different functions intended for a separate logging system: `log()`, `logline()` and `logerror()`.
Let's suppose you don't want to print FTPd messages on screen but you want to write them into different files: _"/var/log/ftpd.log"_ will be main log file, _"/var/log/ftpd.lines.log"_ the one where you'll want to store commands and responses passing through the control connection.

Here's one method this could be implemented:

{{{
import os
import time

from pyftpdlib import ftpserver

now = lambda: time.strftime("[%Y-%b-%d %H:%M:%S]")
f1 = open('ftpd.log', 'a')
f2 = open('ftpd.lines.log', 'a')

def standard_logger(msg):
    f1.write("%s %s\n" %(now(), msg))
    f1.flush()

def line_logger(msg):
    f2.write("%s %s\n" %(now(), msg))
    f2.flush()

def main():
    ftpserver.log = standard_logger
    ftpserver.logline = line_logger
    authorizer = ftpserver.DummyAuthorizer()
    authorizer.add_anonymous(os.getcwd())
    handler = ftpserver.FTPHandler
    handler.authorizer = authorizer
    address = ('', 21)
    server = ftpserver.FTPServer(address, handler)
    server.serve_forever()


if __name__ == "__main__":
    main()
}}}


== 3.3 - Storing passwords as hash digests ==

Using FTP server library with the default `DummyAuthorizer` means that password will be stored in clear-text. An end-user ftpd using the default dummy authorizer would typically require a configuration file for authenticating users and their passwords but storing clear-text passwords is of course undesirable.

The most common way to do things in such case would be first creating new users and then storing their usernames + passwords as hash digests into a file or wherever you find it convenient.

The example below shows how to easily create an encrypted account storage system by storing passwords as one-way hashes by using md5 algorithm.
This could be easily done by using the *hashlib* module included with Python stdlib and by sub-classing the original `DummyAuthorizer` class overriding its `validate_authentication()` method.

[http://pyftpdlib.googlecode.com/svn/trunk/demo/md5_ftpd.py download script]

{{{
import os
try:
    from hashlib import md5
except ImportError:
    from md5 import new as md5  # Python < 2.5

from pyftpdlib import ftpserver


class DummyMD5Authorizer(ftpserver.DummyAuthorizer):

    def validate_authentication(self, username, password):
        hash = md5(password).hexdigest()
        return self.user_table[username]['pwd'] == hash

def main():
    # get a hash digest from a clear-text password
    hash = md5('12345').hexdigest()
    authorizer = DummyMD5Authorizer()
    authorizer.add_user('user', hash, os.getcwd(), perm='elradfmw')
    authorizer.add_anonymous(os.getcwd())
    handler = ftpserver.FTPHandler
    handler.authorizer = authorizer
    address = ('', 21)
    server = ftpserver.FTPServer(address, handler)
    server.serve_forever()

if __name__ == "__main__":
    main()
}}}


== 3.4 - Unix FTP Server ==

If you're running a Unix system you may want to configure your ftpd to include support for "real" users existing on the system and navigate the real filesystem.

The example below uses `UnixAuthorizer` and `UnixFilesystem` classes to do so.

{{{
from pyftpdlib import ftpserver
from pyftpdlib.contrib.authorizers import UnixAuthorizer
from pyftpdlib.contrib.filesystems import UnixFilesystem


def main():
    authorizer = UnixAuthorizer(rejected_users=["root"], require_valid_shell=True)
    handler = ftpserver.FTPHandler
    handler.authorizer = authorizer
    handler.abstracted_fs = UnixFilesystem
    address = ('', 21)
    server = ftpserver.FTPServer(address, handler)
    server.serve_forever()

if __name__ == "__main__":
    main()
}}}

== 3.5 - Windows NT FTP Server ==

The following code shows how to implement a basic authorizer for a Windows NT workstation to authenticate against existing Windows user accounts. This code requires Mark Hammond's [http://starship.python.net/crew/mhammond/win32/ pywin32] extension to be installed.

[http://pyftpdlib.googlecode.com/svn/trunk/demo/winnt_ftpd.py  download script]

{{{
from pyftpdlib import ftpserver
from pyftpdlib.contrib.authorizers import WindowsAuthorizer


def main():
    authorizer = WindowsAuthorizer()
    # Use Guest user with empty password to handle anonymous sessions.
    # Guest user must be enabled first, empty password set and profile
    # directory specified.
    #authorizer = WindowsAuthorizer(anonymous_user="Guest", anonymous_password="")
    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    address = ('', 21)
    ftpd = ftpserver.FTPServer(address, ftp_handler)
    ftpd.serve_forever()

if __name__ == "__main__":
    main()
}}}

== 3.6 - Throttle bandwidth ==

An important feature for an ftpd is limiting the speed for downloads and uploads affecting the data channel. Starting from version 0.5.2 it is possible to use the new `ThrottledDTPHandler` class to set such limits.
The basic idea behind `ThrottledDTPHandler` is to wrap sending and receiving in a data counter and temporary "sleep" the data channel so that you burst to no more than x Kb/sec average. When it realizes that more than x Kb in a second are being transmitted it temporary blocks the transfer for a certain number of seconds.

{{{
import os

from pyftpdlib import ftpserver


def main():
    authorizer = ftpserver.DummyAuthorizer()
    authorizer.add_user('user', '12345', os.getcwd(), perm='elradfmw')
    authorizer.add_anonymous(os.getcwd())

    dtp_handler = ftpserver.ThrottledDTPHandler
    dtp_handler.read_limit = 30720  # 30 Kb/sec (30 * 1024)
    dtp_handler.write_limit = 30720  # 30 Kb/sec (30 * 1024)

    ftp_handler = ftpserver.FTPHandler
    ftp_handler.authorizer = authorizer
    # have the ftp handler use the alternative dtp handler class
    ftp_handler.dtp_handler = dtp_handler

    ftpd = ftpserver.FTPServer(('', 21), ftp_handler)
    ftpd.serve_forever()

if __name__ == '__main__':
    main()
}}}

== 3.7 - FTPS (FTP over TLS/SSL) server ==

Starting from version 0.6.0 pyftpdlib finally includes full FTPS support implementing both TLS and SSL protocols and *AUTH*, *PBSZ* and *PROT* commands as defined in [http://www.ietf.org/rfc/rfc4217.txt RFC-4217]. This has been implemented by using [http://pypi.python.org/pypi/pyOpenSSL PyOpenSSL] module, which is required in order to run the code below. `TLS_FTPHandler` class requires at least a `certfile` to be specified and optionally a `keyfile`. [http://www.modssl.org/docs/2.7/ssl_faq.html#ToC24 Apache FAQs] provide instructions on how to generate them. If you don't care about having your personal self-signed certificates you can use the one in the demo directory which include both and is available [http://pyftpdlib.googlecode.com/svn/trunk/demo/keycert.pem here]. 

[http://pyftpdlib.googlecode.com/svn/trunk/demo/tls_ftpd.py download script]

{{{
#!/usr/bin/env python

"""
An RFC-4217 asynchronous FTPS server supporting both SSL and TLS.
Requires PyOpenSSL module (http://pypi.python.org/pypi/pyOpenSSL).
"""

from pyftpdlib import ftpserver
from pyftpdlib.contrib.handlers import TLS_FTPHandler


def main():
    authorizer = ftpserver.DummyAuthorizer()
    authorizer.add_user('user', '12345', '.', perm='elradfmw')
    authorizer.add_anonymous('.')
    ftp_handler = TLS_FTPHandler
    ftp_handler.certfile = 'keycert.pem'
    ftp_handler.authorizer = authorizer
    # requires SSL for both control and data channel
    #ftp_handler.tls_control_required = True
    #ftp_handler.tls_data_required = True
    ftpd = ftpserver.FTPServer(('', 8021), ftp_handler)
    ftpd.serve_forever()

if __name__ == '__main__':
    main()
}}}

== 3.8 - Event callbacks ==

A small example which shows how to use callback methods via `FTPHandler` subclassing:

{{{
from pyftpdlib import ftpserver

class MyHandler(ftpserver.FTPHandler):

    def on_login(self, username):
        # do something when user login
        pass

    def on_logout(self, username):
        # do something when user logs out
        pass
        
    def on_file_sent(self, file):
        # do something when a file has been sent
        pass

    def on_file_received(self, file):
        # do something when a file has been received
        pass
            
    def on_incomplete_file_sent(self, file):
        # do something when a file is partially sent
        pass

    def on_incomplete_file_received(self, file):
        # remove partially uploaded files
        import os
        os.remove(file)


def main():
    authorizer = ftpserver.DummyAuthorizer()
    authorizer.add_user('user', '12345', homedir='.', perm='elradfmw')
    authorizer.add_anonymous(homedir='.')

    handler = MyHandler
    handler.authorizer = authorizer
    server = ftpserver.FTPServer(('', 21), handler)
    server.serve_forever()

if __name__ == "__main__":
    main()
}}}

== 3.9 - Command line usage ==

Starting from version 0.6.0 pyftpdlib can be run as a simple stand-alone server via Python's -m option, which is particularly useful when you want to quickly share a directory. Some examples.

Anonymous FTPd sharing current directory:

{{{
python -m pyftpdlib.ftpserver
}}}

Anonymous FTPd with write permission:

{{{
python -m pyftpdlib.ftpserver -w
}}}

Set a different address/port and home directory:

{{{
python -m pyftpdlib.ftpserver -i localhost -p 8021 -d /home/someone
}}}

See `python -m pyftpdlib.ftpserver -h` for a complete list of options.